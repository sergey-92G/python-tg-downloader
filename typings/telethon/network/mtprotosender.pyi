"""
This type stub file was generated by pyright.
"""

class MTProtoSender:
    """
    MTProto Mobile Protocol sender
    (https://core.telegram.org/mtproto/description).

    This class is responsible for wrapping requests into `TLMessage`'s,
    sending them over the network and receiving them in a safe manner.

    Automatic reconnection due to temporary network issues is a concern
    for this class as well, including retry of messages that could not
    be sent successfully.

    A new authorization key will be generated on connection if no other
    key exists yet.
    """
    def __init__(self, auth_key, *, loggers, retries=..., delay=..., auto_reconnect=..., connect_timeout=..., auth_key_callback=..., updates_queue=..., auto_reconnect_callback=...) -> None:
        ...
    
    async def connect(self, connection): # -> bool:
        """
        Connects to the specified given connection using the given auth key.
        """
        ...
    
    def is_connected(self): # -> bool:
        ...
    
    async def disconnect(self): # -> None:
        """
        Cleanly disconnects the instance from the network, cancels
        all pending requests, and closes the send and receive loops.
        """
        ...
    
    def send(self, request, ordered=...): # -> Future[Any] | list[Any]:
        """
        This method enqueues the given request to be sent. Its send
        state will be saved until a response arrives, and a ``Future``
        that will be resolved when the response arrives will be returned:

        .. code-block:: python

            async def method():
                # Sending (enqueued for the send loop)
                future = sender.send(request)
                # Receiving (waits for the receive loop to read the result)
                result = await future

        Designed like this because Telegram may send the response at
        any point, and it can send other items while one waits for it.
        Once the response for this future arrives, it is set with the
        received result, quite similar to how a ``receive()`` call
        would otherwise work.

        Since the receiving part is "built in" the future, it's
        impossible to await receive a result that was never sent.
        """
        ...
    
    @property
    def disconnected(self): # -> Future[Any]:
        """
        Future that resolves when the connection to Telegram
        ends, either by user action or in the background.

        Note that it may resolve in either a ``ConnectionError``
        or any other unexpected error that could not be handled.
        """
        ...
    


