"""
This type stub file was generated by pyright.
"""

from typing import Optional
from enum import IntEnum

class SessionState:
    """
    Stores the information needed to fetch updates and about the current user.

    * user_id: 64-bit number representing the user identifier.
    * dc_id: 32-bit number relating to the datacenter identifier where the user is.
    * bot: is the logged-in user a bot?
    * pts: 64-bit number holding the state needed to fetch updates.
    * qts: alternative 64-bit number holding the state needed to fetch updates.
    * date: 64-bit number holding the date needed to fetch updates.
    * seq: 64-bit-number holding the sequence number needed to fetch updates.
    * takeout_id: 64-bit-number holding the identifier of the current takeout session.

    Note that some of the numbers will only use 32 out of the 64 available bits.
    However, for future-proofing reasons, we recommend you pretend they are 64-bit long.
    """
    __slots__ = ...
    def __init__(self, user_id: int, dc_id: int, bot: bool, pts: int, qts: int, date: int, seq: int, takeout_id: Optional[int]) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ChannelState:
    """
    Stores the information needed to fetch updates from a channel.

    * channel_id: 64-bit number representing the channel identifier.
    * pts: 64-bit number holding the state needed to fetch updates.
    """
    __slots__ = ...
    def __init__(self, channel_id: int, pts: int) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class EntityType(IntEnum):
    """
    You can rely on the type value to be equal to the ASCII character one of:

    * 'U' (85): this entity belongs to a :tl:`User` who is not a ``bot``.
    * 'B' (66): this entity belongs to a :tl:`User` who is a ``bot``.
    * 'G' (71): this entity belongs to a small group :tl:`Chat`.
    * 'C' (67): this entity belongs to a standard broadcast :tl:`Channel`.
    * 'M' (77): this entity belongs to a megagroup :tl:`Channel`.
    * 'E' (69): this entity belongs to an "enormous" "gigagroup" :tl:`Channel`.
    """
    USER = ...
    BOT = ...
    GROUP = ...
    CHANNEL = ...
    MEGAGROUP = ...
    GIGAGROUP = ...
    def canonical(self): # -> EntityType:
        """
        Return the canonical version of this type.
        """
        ...
    


_canon_entity_types = ...
class Entity:
    """
    Stores the information needed to use a certain user, chat or channel with the API.

    * ty: 8-bit number indicating the type of the entity (of type `EntityType`).
    * id: 64-bit number uniquely identifying the entity among those of the same type.
    * hash: 64-bit signed number needed to use this entity with the API.

    The string representation of this class is considered to be stable, for as long as
    Telegram doesn't need to add more fields to the entities. It can also be converted
    to bytes with ``bytes(entity)``, for a more compact representation.
    """
    __slots__ = ...
    def __init__(self, ty: EntityType, id: int, hash: int) -> None:
        ...
    
    @property
    def is_user(self): # -> bool:
        """
        ``True`` if the entity is either a user or a bot.
        """
        ...
    
    @property
    def is_group(self): # -> bool:
        """
        ``True`` if the entity is a small group chat or `megagroup`_.

        .. _megagroup: https://telegram.org/blog/supergroups5k
        """
        ...
    
    @property
    def is_broadcast(self): # -> bool:
        """
        ``True`` if the entity is a broadcast channel or `broadcast group`_.

        .. _broadcast group: https://telegram.org/blog/autodelete-inv2#groups-with-unlimited-members
        """
        ...
    
    @classmethod
    def from_str(cls, string: str): # -> Self:
        """
        Convert the string into an `Entity`.
        """
        ...
    
    @classmethod
    def from_bytes(cls, blob): # -> Self:
        """
        Convert the bytes into an `Entity`.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    
    def __repr__(self): # -> str:
        ...
    


