"""
This type stub file was generated by pyright.
"""

import datetime
from enum import Enum

"""
This module deals with correct handling of updates, including gaps, and knowing when the code
should "get difference" (the set of updates that the client should know by now minus the set
of updates that it actually knows).

Each chat has its own [`Entry`] in the [`MessageBox`] (this `struct` is the "entry point").
At any given time, the message box may be either getting difference for them (entry is in
[`MessageBox::getting_diff_for`]) or not. If not getting difference, a possible gap may be
found for the updates (entry is in [`MessageBox::possible_gaps`]). Otherwise, the entry is
on its happy path.

Gaps are cleared when they are either resolved on their own (by waiting for a short time)
or because we got the difference for the corresponding entry.

While there are entries for which their difference must be fetched,
[`MessageBox::check_deadlines`] will always return [`Instant::now`], since "now" is the time
to get the difference.
"""
NO_SEQ = ...
BOT_CHANNEL_DIFF_LIMIT = ...
USER_CHANNEL_DIFF_LIMIT = ...
POSSIBLE_GAP_TIMEOUT = ...
NO_UPDATES_TIMEOUT = ...
class Sentinel:
    __slots__ = ...
    def __init__(self, tag=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


ENTRY_ACCOUNT = ...
ENTRY_SECRET = ...
LOG_LEVEL_TRACE = ...
_sentinel = ...
def next_updates_deadline(): # -> float:
    ...

def epoch(): # -> datetime:
    ...

class GapError(ValueError):
    def __repr__(self): # -> Literal['GapError()']:
        ...
    


class PrematureEndReason(Enum):
    TEMPORARY_SERVER_ISSUES = ...
    BANNED = ...


class PtsInfo:
    __slots__ = ...
    def __init__(self, pts: int, pts_count: int, entry: object) -> None:
        ...
    
    @classmethod
    def from_update(cls, update): # -> Self | None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class State:
    __slots__ = ...
    def __init__(self, pts: int, deadline: float) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class PossibleGap:
    __slots__ = ...
    def __init__(self, deadline: float, updates: list) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class MessageBox:
    __slots__ = ...
    def __init__(self, log, map: dict = ..., date: datetime.datetime = ..., seq: int = ..., next_deadline: object = ..., possible_gaps: dict = ..., getting_diff_for: set = ...) -> None:
        ...
    
    def load(self, session_state, channel_states): # -> None:
        """
        Create a [`MessageBox`] from a previously known update state.
        """
        ...
    
    def session_state(self): # -> tuple[dict[str, int | Any], dict[int, Any]]:
        """
        Return the current state.

        This should be used for persisting the state.
        """
        ...
    
    def is_empty(self) -> bool:
        """
        Return true if the message box is empty and has no state yet.
        """
        ...
    
    def check_deadlines(self): # -> float:
        """
        Return the next deadline when receiving updates should timeout.

        If a deadline expired, the corresponding entries will be marked as needing to get its difference.
        While there are entries pending of getting their difference, this method returns the current instant.
        """
        ...
    
    def reset_deadlines(self, entries, deadline): # -> None:
        ...
    
    def reset_channel_deadline(self, channel_id, timeout): # -> None:
        ...
    
    def set_state(self, state, reset=...): # -> None:
        ...
    
    def try_set_channel_state(self, id, pts): # -> None:
        ...
    
    def try_begin_get_diff(self, entry, reason): # -> None:
        ...
    
    def end_get_diff(self, entry): # -> None:
        ...
    
    def process_updates(self, updates, chat_hashes, result): # -> tuple[Any | list[Any], Any | list[Any]]:
        ...
    
    def apply_pts_info(self, update, *, reset_deadlines, any_pts_applied=...): # -> None:
        ...
    
    def get_difference(self): # -> GetDifferenceRequest | None:
        ...
    
    def apply_difference(self, diff, chat_hashes): # -> tuple[list[Any], list[Any], list[Any]] | tuple[list[Any], Any, Any] | None:
        ...
    
    def apply_difference_type(self, diff, chat_hashes): # -> tuple[list[Any], Any, Any]:
        ...
    
    def end_difference(self): # -> None:
        ...
    
    def get_channel_difference(self, chat_hashes): # -> GetChannelDifferenceRequest | None:
        ...
    
    def apply_channel_difference(self, request, diff, chat_hashes): # -> tuple[list[Any], list[Any], list[Any]] | tuple[list[Any], List[TypeUser], List[TypeChat]] | None:
        ...
    
    def end_channel_difference(self, request, reason: PrematureEndReason, chat_hashes): # -> None:
        ...
    


