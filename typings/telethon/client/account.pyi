"""
This type stub file was generated by pyright.
"""

import typing
from .telegramclient import TelegramClient

if typing.TYPE_CHECKING:
    ...
class _TakeoutClient:
    """
    Proxy object over the client.
    """
    __PROXY_INTERFACE = ...
    def __init__(self, finalize, client, request) -> None:
        ...
    
    @property
    def success(self): # -> bool | None:
        ...
    
    @success.setter
    def success(self, value): # -> None:
        ...
    
    async def __aenter__(self): # -> Self:
        ...
    
    async def __aexit__(self, exc_type, exc_value, traceback): # -> None:
        ...
    
    __enter__ = ...
    __exit__ = ...
    async def __call__(self, request, ordered=...):
        ...
    
    def __getattribute__(self, name): # -> Any:
        ...
    
    def __getattr__(self, name): # -> partial[Any] | Any:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    


class AccountMethods:
    def takeout(self: TelegramClient, finalize: bool = ..., *, contacts: bool = ..., users: bool = ..., chats: bool = ..., megagroups: bool = ..., channels: bool = ..., files: bool = ..., max_file_size: bool = ...) -> TelegramClient:
        """
        Returns a :ref:`telethon-client` which calls methods behind a takeout session.

        It does so by creating a proxy object over the current client through
        which making requests will use :tl:`InvokeWithTakeoutRequest` to wrap
        them. In other words, returns the current client modified so that
        requests are done as a takeout:

        Some of the calls made through the takeout session will have lower
        flood limits. This is useful if you want to export the data from
        conversations or mass-download media, since the rate limits will
        be lower. Only some requests will be affected, and you will need
        to adjust the `wait_time` of methods like `client.iter_messages
        <telethon.client.messages.MessageMethods.iter_messages>`.

        By default, all parameters are `None`, and you need to enable those
        you plan to use by setting them to either `True` or `False`.

        You should ``except errors.TakeoutInitDelayError as e``, since this
        exception will raise depending on the condition of the session. You
        can then access ``e.seconds`` to know how long you should wait for
        before calling the method again.

        There's also a `success` property available in the takeout proxy
        object, so from the `with` body you can set the boolean result that
        will be sent back to Telegram. But if it's left `None` as by
        default, then the action is based on the `finalize` parameter. If
        it's `True` then the takeout will be finished, and if no exception
        occurred during it, then `True` will be considered as a result.
        Otherwise, the takeout will not be finished and its ID will be
        preserved for future usage as `client.session.takeout_id
        <telethon.sessions.abstract.Session.takeout_id>`.

        Arguments
            finalize (`bool`):
                Whether the takeout session should be finalized upon
                exit or not.

            contacts (`bool`):
                Set to `True` if you plan on downloading contacts.

            users (`bool`):
                Set to `True` if you plan on downloading information
                from users and their private conversations with you.

            chats (`bool`):
                Set to `True` if you plan on downloading information
                from small group chats, such as messages and media.

            megagroups (`bool`):
                Set to `True` if you plan on downloading information
                from megagroups (channels), such as messages and media.

            channels (`bool`):
                Set to `True` if you plan on downloading information
                from broadcast channels, such as messages and media.

            files (`bool`):
                Set to `True` if you plan on downloading media and
                you don't only wish to export messages.

            max_file_size (`int`):
                The maximum file size, in bytes, that you plan
                to download for each message with media.

        Example
            .. code-block:: python

                from telethon import errors

                try:
                    async with client.takeout() as takeout:
                        await client.get_messages('me')  # normal call
                        await takeout.get_messages('me')  # wrapped through takeout (less limits)

                        async for message in takeout.iter_messages(chat, wait_time=0):
                            ...  # Do something with the message

                except errors.TakeoutInitDelayError as e:
                    print('Must wait', e.seconds, 'before takeout')
        """
        ...
    
    async def end_takeout(self: TelegramClient, success: bool) -> bool:
        """
        Finishes the current takeout session.

        Arguments
            success (`bool`):
                Whether the takeout completed successfully or not.

        Returns
            `True` if the operation was successful, `False` otherwise.

        Example
            .. code-block:: python

                await client.end_takeout(success=False)
        """
        ...
    


