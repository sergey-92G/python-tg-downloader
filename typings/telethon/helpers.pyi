"""
This type stub file was generated by pyright.
"""

import io
import enum

"""Various helpers not related to the Telegram API itself"""
class _EntityType(enum.Enum):
    USER = ...
    CHAT = ...
    CHANNEL = ...


_log = ...
def generate_random_long(signed=...): # -> int:
    """Generates a random long integer (8 bytes), which is optionally signed"""
    ...

def ensure_parent_dir_exists(file_path): # -> None:
    """Ensures that the parent directory exists"""
    ...

def add_surrogate(text): # -> str:
    ...

def del_surrogate(text):
    ...

def within_surrogate(text, index, *, length=...):
    """
    `True` if ``index`` is within a surrogate (before and after it, not at!).
    """
    ...

def strip_text(text, entities):
    """
    Strips whitespace from the given surrogated text modifying the provided
    entities, also removing any empty (0-length) entities.

    This assumes that the length of entities is greater or equal to 0, and
    that no entity is out of bounds.
    """
    ...

def retry_range(retries, force_retry=...): # -> Generator[int, Any, None]:
    """
    Generates an integer sequence starting from 1. If `retries` is
    not a zero or a positive integer value, the sequence will be
    infinite, otherwise it will end at `retries + 1`.
    """
    ...

def generate_key_data_from_nonce(server_nonce, new_nonce): # -> tuple[bytes, Any]:
    """Generates the key data corresponding to the given nonce"""
    ...

class TotalList(list):
    """
    A list with an extra `total` property, which may not match its `len`
    since the total represents the total amount of items *available*
    somewhere else, not the items *in this list*.

    Examples:

        .. code-block:: python

            # Telethon returns these lists in some cases (for example,
            # only when a chunk is returned, but the "total" count
            # is available).
            result = await client.get_messages(chat, limit=10)

            print(result.total)  # large number
            print(len(result))  # 10
            print(result[0])  # latest message

            for x in result:  # show the 10 messages
                print(x.text)

    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _FileStream(io.IOBase):
    """
    Proxy around things that represent a file and need to be used as streams
    which may or not need to be closed.

    This will handle `pathlib.Path`, `str` paths, in-memory `bytes`, and
    anything IO-like (including `aiofiles`).

    It also provides access to the name and file size (also necessary).
    """
    def __init__(self, file, *, file_size=...) -> None:
        ...
    
    async def __aenter__(self): # -> Self:
        ...
    
    async def __aexit__(self, exc_type, exc_val, exc_tb): # -> None:
        ...
    
    @property
    def file_size(self): # -> int | Any | None:
        ...
    
    @property
    def name(self): # -> str | Any | None:
        ...
    
    def read(self, *args, **kwargs): # -> bytes:
        ...
    
    def readinto(self, *args, **kwargs): # -> int:
        ...
    
    def write(self, *args, **kwargs): # -> int:
        ...
    
    def fileno(self, *args, **kwargs): # -> int:
        ...
    
    def flush(self, *args, **kwargs): # -> None:
        ...
    
    def isatty(self, *args, **kwargs): # -> bool:
        ...
    
    def readable(self, *args, **kwargs): # -> bool:
        ...
    
    def readline(self, *args, **kwargs): # -> bytes:
        ...
    
    def readlines(self, *args, **kwargs): # -> list[bytes]:
        ...
    
    def seek(self, *args, **kwargs): # -> int:
        ...
    
    def seekable(self, *args, **kwargs): # -> bool:
        ...
    
    def tell(self, *args, **kwargs): # -> int:
        ...
    
    def truncate(self, *args, **kwargs): # -> int:
        ...
    
    def writable(self, *args, **kwargs): # -> bool:
        ...
    
    def writelines(self, *args, **kwargs): # -> None:
        ...
    
    def close(self, *args, **kwargs): # -> None:
        ...
    


def get_running_loop(): # -> AbstractEventLoop:
    ...

