"""
This type stub file was generated by pyright.
"""

"""
Utilities for working with the Telegram API itself (such as handy methods
to convert between an entity like a User, Chat, etc. into its Input version)
"""
USERNAME_RE = ...
TG_JOIN_RE = ...
VALID_USERNAME_RE = ...
_FileInfo = ...
_log = ...
def chunks(iterable, size=...): # -> Generator[chain[Any], Any, None]:
    """
    Turns the given iterable into chunks of the specified size,
    which is 100 by default since that's what Telegram uses the most.
    """
    ...

def get_display_name(entity): # -> str:
    """
    Gets the display name for the given :tl:`User`,
    :tl:`Chat` or :tl:`Channel`. Returns an empty string otherwise.
    """
    ...

def get_extension(media): # -> str:
    """Gets the corresponding extension for any Telegram media."""
    ...

def get_input_peer(entity, allow_self=..., check_hash=...): # -> InputPeerSelf | InputPeerUser | InputPeerChat | InputPeerChannel | InputPeerUserFromMessage | InputPeerChannelFromMessage | InputPeerEmpty | None:
    """
    Gets the input peer for the given "entity" (user, chat or channel).

    A ``TypeError`` is raised if the given entity isn't a supported type
    or if ``check_hash is True`` but the entity's ``access_hash is None``
    *or* the entity contains ``min`` information. In this case, the hash
    cannot be used for general purposes, and thus is not returned to avoid
    any issues which can derive from invalid access hashes.

    Note that ``check_hash`` **is ignored** if an input peer is already
    passed since in that case we assume the user knows what they're doing.
    This is key to getting entities by explicitly passing ``hash = 0``.
    """
    ...

def get_input_channel(entity): # -> InputChannel | InputChannelFromMessage | None:
    """
    Similar to :meth:`get_input_peer`, but for :tl:`InputChannel`'s alone.

    .. important::

        This method does not validate for invalid general-purpose access
        hashes, unlike `get_input_peer`. Consider using instead:
        ``get_input_channel(get_input_peer(channel))``.
    """
    ...

def get_input_user(entity): # -> InputUserSelf | InputUser | InputUserEmpty | InputUserFromMessage | None:
    """
    Similar to :meth:`get_input_peer`, but for :tl:`InputUser`'s alone.

    .. important::

        This method does not validate for invalid general-purpose access
        hashes, unlike `get_input_peer`. Consider using instead:
        ``get_input_channel(get_input_peer(channel))``.
    """
    ...

def get_input_dialog(dialog): # -> InputDialogPeer | None:
    """Similar to :meth:`get_input_peer`, but for dialogs"""
    ...

def get_input_document(document): # -> InputDocument | InputDocumentEmpty | None:
    """Similar to :meth:`get_input_peer`, but for documents"""
    ...

def get_input_photo(photo): # -> InputPhoto | InputPhotoEmpty | None:
    """Similar to :meth:`get_input_peer`, but for photos"""
    ...

def get_input_chat_photo(photo): # -> InputChatUploadedPhoto | InputChatPhoto | InputChatPhotoEmpty | None:
    """Similar to :meth:`get_input_peer`, but for chat photos"""
    ...

def get_input_geo(geo): # -> InputGeoPoint | InputGeoPointEmpty | None:
    """Similar to :meth:`get_input_peer`, but for geo points"""
    ...

def get_input_media(media, *, is_photo=..., attributes=..., force_document=..., voice_note=..., video_note=..., supports_streaming=..., ttl=...):
    """
    Similar to :meth:`get_input_peer`, but for media.

    If the media is :tl:`InputFile` and ``is_photo`` is known to be `True`,
    it will be treated as an :tl:`InputMediaUploadedPhoto`. Else, the rest
    of parameters will indicate how to treat it.
    """
    ...

def get_input_message(message): # -> InputMessageID | None:
    """Similar to :meth:`get_input_peer`, but for input messages."""
    ...

def get_input_group_call(call): # -> InputGroupCall | None:
    """Similar to :meth:`get_input_peer`, but for input calls."""
    ...

def get_message_id(message): # -> int | None:
    """Similar to :meth:`get_input_peer`, but for message IDs."""
    ...

def get_attributes(file, *, attributes=..., mime_type=..., force_document=..., voice_note=..., video_note=..., supports_streaming=..., thumb=...): # -> tuple[list[DocumentAttributeFilename], str | Any]:
    """
    Get a list of attributes for the given file and
    the mime type as a tuple ([attribute], mime_type).
    """
    ...

def sanitize_parse_mode(mode): # -> type[CustomMode] | ModuleType | None:
    """
    Converts the given parse mode into an object with
    ``parse`` and ``unparse`` callable properties.
    """
    ...

def get_input_location(location): # -> tuple[Any, Any]:
    """
    Similar to :meth:`get_input_peer`, but for input messages.

    Note that this returns a tuple ``(dc_id, location)``, the
    ``dc_id`` being present if known.
    """
    ...

def is_image(file): # -> bool:
    """
    Returns `True` if the file extension looks like an image file to Telegram.
    """
    ...

def is_gif(file): # -> Match[str] | None:
    """
    Returns `True` if the file extension looks like a gif file to Telegram.
    """
    ...

def is_audio(file): # -> bool:
    """Returns `True` if the file has an audio mime type."""
    ...

def is_video(file): # -> bool:
    """Returns `True` if the file has a video mime type."""
    ...

def is_list_like(obj): # -> bool:
    """
    Returns `True` if the given object looks like a list.

    Checking ``if hasattr(obj, '__iter__')`` and ignoring ``str/bytes`` is not
    enough. Things like ``open()`` are also iterable (and probably many
    other things), so just support the commonly known list-like objects.
    """
    ...

def parse_phone(phone): # -> str | None:
    """Parses the given phone, or returns `None` if it's invalid."""
    ...

def parse_username(username): # -> tuple[Any, Literal[True]] | tuple[Any, Literal[False]] | tuple[None, Literal[False]]:
    """
    Parses the given username or channel access hash, given
    a string, username or URL. Returns a tuple consisting of
    both the stripped, lowercase username and whether it is
    a joinchat/ hash (in which case is not lowercase'd).

    Returns ``(None, False)`` if the ``username`` or link is not valid.
    """
    ...

def get_inner_text(text, entities): # -> list[Any]:
    """
    Gets the inner text that's surrounded by the given entities.
    For instance: text = 'hey!', entity = MessageEntityBold(2, 2) -> 'y!'.

    :param text:     the original text.
    :param entities: the entity or entities that must be matched.
    :return: a single result or a list of the text surrounded by the entities.
    """
    ...

def get_peer(peer): # -> TypePeer | TypeInputPeer | None:
    ...

def get_peer_id(peer, add_mark=...): # -> int:
    """
    Convert the given peer into its marked ID by default.

    This "mark" comes from the "bot api" format, and with it the peer type
    can be identified back. User ID is left unmodified, chat ID is negated,
    and channel ID is "prefixed" with -100:

    * ``user_id``
    * ``-chat_id``
    * ``-100channel_id``

    The original ID and the peer type class can be returned with
    a call to :meth:`resolve_id(marked_id)`.
    """
    ...

def resolve_id(marked_id): # -> tuple[Any, type[PeerUser]] | tuple[Any, type[PeerChannel]] | tuple[Any, type[PeerChat]]:
    """Given a marked ID, returns the original ID and its :tl:`Peer` type."""
    ...

def resolve_bot_file_id(file_id): # -> Document | Photo | None:
    """
    Given a Bot API-style `file_id <telethon.tl.custom.file.File.id>`,
    returns the media it represents. If the `file_id <telethon.tl.custom.file.File.id>`
    is not valid, `None` is returned instead.

    Note that the `file_id <telethon.tl.custom.file.File.id>` does not have information
    such as image dimensions or file size, so these will be zero if present.

    For thumbnails, the photo ID and hash will always be zero.
    """
    ...

def pack_bot_file_id(file): # -> str | None:
    """
    Inverse operation for `resolve_bot_file_id`.

    The only parameters this method will accept are :tl:`Document` and
    :tl:`Photo`, and it will return a variable-length ``file_id`` string.

    If an invalid parameter is given, it will ``return None``.
    """
    ...

def resolve_invite_link(link): # -> tuple[Literal[0], *tuple[Any, ...]] | tuple[Any, ...] | tuple[None, None, None]:
    """
    Resolves the given invite link. Returns a tuple of
    ``(link creator user id, global chat id, random int)``.

    Note that for broadcast channels or with the newest link format, the link
    creator user ID will be zero to protect their identity. Normal chats and
    megagroup channels will have such ID.

    Note that the chat ID may not be accurate for chats with a link that were
    upgraded to megagroup, since the link can remain the same, but the chat
    ID will be correct once a new link is generated.
    """
    ...

def resolve_inline_message_id(inline_msg_id): # -> tuple[Any, PeerChannel | PeerUser, Any, Any] | tuple[None, None, None, None]:
    """
    Resolves an inline message ID. Returns a tuple of
    ``(message id, peer, dc id, access hash)``

    The ``peer`` may either be a :tl:`PeerUser` referencing
    the user who sent the message via the bot in a private
    conversation or small group chat, or a :tl:`PeerChannel`
    if the message was sent in a channel.

    The ``access_hash`` does not have any use yet.
    """
    ...

def get_appropriated_part_size(file_size): # -> Literal[128, 256, 512]:
    """
    Gets the appropriated part size when uploading or downloading files,
    given an initial file size.
    """
    ...

def encode_waveform(waveform): # -> bytes:
    """
    Encodes the input `bytes` into a 5-bit byte-string
    to be used as a voice note's waveform. See `decode_waveform`
    for the reverse operation.

    Example
        .. code-block:: python

            chat = ...
            file = 'my.ogg'

            # Send 'my.ogg' with a ascending-triangle waveform
            await client.send_file(chat, file, attributes=[types.DocumentAttributeAudio(
                duration=7,
                voice=True,
                waveform=utils.encode_waveform(bytes(range(2 ** 5))  # 2**5 because 5-bit
            )]

            # Send 'my.ogg' with a square waveform
            await client.send_file(chat, file, attributes=[types.DocumentAttributeAudio(
                duration=7,
                voice=True,
                waveform=utils.encode_waveform(bytes((31, 31, 15, 15, 15, 15, 31, 31)) * 4)
            )]
    """
    ...

def decode_waveform(waveform): # -> bytes:
    """
    Inverse operation of `encode_waveform`.
    """
    ...

def split_text(text, entities, *, limit=..., max_entities=..., split_at=...): # -> Generator[tuple[str, list[Any]] | tuple[str, Any | list[Any]], Any, None]:
    """
    Split a message text and entities into multiple messages, each with their
    own set of entities. This allows sending a very large message as multiple
    messages while respecting the formatting.

    Arguments
        text (`str`):
            The message text.

        entities (List[:tl:`MessageEntity`])
            The formatting entities.

        limit (`int`):
            The maximum message length of each individual message.

        max_entities (`int`):
            The maximum amount of entities that will be present in each
            individual message.

        split_at (Tuplel[`str`]):
            The list of regular expressions that will determine where to split
            the text. By default, a newline is searched. If no newline is
            present, a space is searched. If no space is found, the split will
            be made at any character.

            The last expression should always match a character, or else the
            text will stop being splitted and the resulting text may be larger
            than the limit.

    Yields
        Pairs of ``(str, entities)`` with the split message.

    Example
        .. code-block:: python

            from telethon import utils
            from telethon.extensions import markdown

            very_long_markdown_text = "..."
            text, entities = markdown.parse(very_long_markdown_text)

            for text, entities in utils.split_text(text, entities):
                await client.send_message(chat, text, formatting_entities=entities)
    """
    ...

class AsyncClassWrapper:
    def __init__(self, wrapped) -> None:
        ...
    
    def __getattr__(self, item): # -> Callable[..., CoroutineType[Any, Any, Any]] | Any:
        ...
    


def stripped_photo_to_jpg(stripped):
    """
    Adds the JPG header and footer to a stripped image.

    Ported from https://github.com/telegramdesktop/tdesktop/blob/bec39d89e19670eb436dc794a8f20b657cb87c71/Telegram/SourceFiles/ui/image/image.cpp#L225
    """
    ...

