"""
This type stub file was generated by pyright.
"""

from typing import List, Optional
from datetime import datetime
from .chatgetter import ChatGetter
from .sendergetter import SenderGetter
from .. import TLObject, types

class Message(ChatGetter, SenderGetter, TLObject):
    """
    This custom class aggregates both :tl:`Message` and
    :tl:`MessageService` to ease accessing their members.

    Remember that this class implements `ChatGetter
    <telethon.tl.custom.chatgetter.ChatGetter>` and `SenderGetter
    <telethon.tl.custom.sendergetter.SenderGetter>` which means you
    have access to all their sender and chat properties and methods.

    Members:
        out (`bool`):
            Whether the message is outgoing (i.e. you sent it from
            another session) or incoming (i.e. someone else sent it).

            Note that messages in your own chat are always incoming,
            but this member will be `True` if you send a message
            to your own chat. Messages you forward to your chat are
            *not* considered outgoing, just like official clients
            display them.

        mentioned (`bool`):
            Whether you were mentioned in this message or not.
            Note that replies to your own messages also count
            as mentions.

        media_unread (`bool`):
            Whether you have read the media in this message
            or not, e.g. listened to the voice note media.

        silent (`bool`):
            Whether the message should notify people with sound or not.
            Previously used in channels, but since 9 August 2019, it can
            also be `used in private chats
            <https://telegram.org/blog/silent-messages-slow-mode>`_.

        post (`bool`):
            Whether this message is a post in a broadcast
            channel or not.

        from_scheduled (`bool`):
            Whether this message was originated from a previously-scheduled
            message or not.

        legacy (`bool`):
            Whether this is a legacy message or not.

        edit_hide (`bool`):
            Whether the edited mark of this message is edited
            should be hidden (e.g. in GUI clients) or shown.

        pinned (`bool`):
            Whether this message is currently pinned or not.

        noforwards (`bool`):
            Whether this message can be forwarded or not.

        invert_media (`bool`):
            Whether the media in this message should be inverted.
            
        offline (`bool`):
            Whether the message was sent by an implicit action, for example, as an away or a greeting business message, or as a scheduled message.

        id (`int`):
            The ID of this message. This field is *always* present.
            Any other member is optional and may be `None`.

        from_id (:tl:`Peer`):
            The peer who sent this message, which is either
            :tl:`PeerUser`, :tl:`PeerChat` or :tl:`PeerChannel`.
            This value will be `None` for anonymous messages.

        peer_id (:tl:`Peer`):
            The peer to which this message was sent, which is either
            :tl:`PeerUser`, :tl:`PeerChat` or :tl:`PeerChannel`. This
            will always be present except for empty messages.

        fwd_from (:tl:`MessageFwdHeader`):
            The original forward header if this message is a forward.
            You should probably use the `forward` property instead.

        via_bot_id (`int`):
            The ID of the bot used to send this message
            through its inline mode (e.g. "via @like").

        reply_to (:tl:`MessageReplyHeader`):
            The original reply header if this message is replying to another.

        date (`datetime`):
            The UTC+0 `datetime` object indicating when this message
            was sent. This will always be present except for empty
            messages.

        message (`str`):
            The string text of the message for `Message
            <telethon.tl.custom.message.Message>` instances,
            which will be `None` for other types of messages.

        media (:tl:`MessageMedia`):
            The media sent with this message if any (such as
            photos, videos, documents, gifs, stickers, etc.).

            You may want to access the `photo`, `document`
            etc. properties instead.

            If the media was not present or it was :tl:`MessageMediaEmpty`,
            this member will instead be `None` for convenience.

        reply_markup (:tl:`ReplyMarkup`):
            The reply markup for this message (which was sent
            either via a bot or by a bot). You probably want
            to access `buttons` instead.

        entities (List[:tl:`MessageEntity`]):
            The list of markup entities in this message,
            such as bold, italics, code, hyperlinks, etc.

        views (`int`):
            The number of views this message from a broadcast
            channel has. This is also present in forwards.

        forwards (`int`):
            The number of times this message has been forwarded.

        replies (`int`):
            The number of times another message has replied to this message.

        edit_date (`datetime`):
            The date when this message was last edited.

        post_author (`str`):
            The display name of the message sender to
            show in messages sent to broadcast channels.

        grouped_id (`int`):
            If this message belongs to a group of messages
            (photo albums or video albums), all of them will
            have the same value here.

        reactions (:tl:`MessageReactions`)
            Reactions to this message.

        restriction_reason (List[:tl:`RestrictionReason`])
            An optional list of reasons why this message was restricted.
            If the list is `None`, this message has not been restricted.

        ttl_period (`int`):
            The Time To Live period configured for this message.
            The message should be erased from wherever it's stored (memory, a
            local database, etc.) when
            ``datetime.now() > message.date + timedelta(seconds=message.ttl_period)``.

        action (:tl:`MessageAction`):
            The message action object of the message for :tl:`MessageService`
            instances, which will be `None` for other types of messages.

        saved_peer_id (:tl:`Peer`)
    """
    def __init__(self, id: int, peer_id: types.TypePeer, date: Optional[datetime] = ..., message: Optional[str] = ..., out: Optional[bool] = ..., mentioned: Optional[bool] = ..., media_unread: Optional[bool] = ..., silent: Optional[bool] = ..., post: Optional[bool] = ..., from_scheduled: Optional[bool] = ..., legacy: Optional[bool] = ..., edit_hide: Optional[bool] = ..., pinned: Optional[bool] = ..., noforwards: Optional[bool] = ..., invert_media: Optional[bool] = ..., offline: Optional[bool] = ..., video_processing_pending: Optional[bool] = ..., from_id: Optional[types.TypePeer] = ..., from_boosts_applied: Optional[int] = ..., saved_peer_id: Optional[types.TypePeer] = ..., fwd_from: Optional[types.TypeMessageFwdHeader] = ..., via_bot_id: Optional[int] = ..., via_business_bot_id: Optional[int] = ..., reply_to: Optional[types.TypeMessageReplyHeader] = ..., media: Optional[types.TypeMessageMedia] = ..., reply_markup: Optional[types.TypeReplyMarkup] = ..., entities: Optional[List[types.TypeMessageEntity]] = ..., views: Optional[int] = ..., forwards: Optional[int] = ..., replies: Optional[types.TypeMessageReplies] = ..., edit_date: Optional[datetime] = ..., post_author: Optional[str] = ..., grouped_id: Optional[int] = ..., reactions: Optional[types.TypeMessageReactions] = ..., restriction_reason: Optional[List[types.TypeRestrictionReason]] = ..., ttl_period: Optional[int] = ..., quick_reply_shortcut_id: Optional[int] = ..., effect: Optional[int] = ..., factcheck: Optional[types.TypeFactCheck] = ..., report_delivery_until_date: Optional[datetime] = ..., paid_message_stars: Optional[int] = ..., action: Optional[types.TypeMessageAction] = ..., reactions_are_possible: Optional[bool] = ...) -> None:
        ...
    
    @property
    def client(self): # -> None:
        """
        Returns the `TelegramClient <telethon.client.telegramclient.TelegramClient>`
        that *patched* this message. This will only be present if you
        **use the friendly methods**, it won't be there if you invoke
        raw API methods manually, in which case you should only access
        members, not properties.
        """
        ...
    
    @property
    def text(self): # -> str | None:
        """
        The message text, formatted using the client's default
        parse mode. Will be `None` for :tl:`MessageService`.
        """
        ...
    
    @text.setter
    def text(self, value): # -> None:
        ...
    
    @property
    def raw_text(self): # -> str | None:
        """
        The raw message text, ignoring any formatting.
        Will be `None` for :tl:`MessageService`.

        Setting a value to this field will erase the
        `entities`, unlike changing the `message` member.
        """
        ...
    
    @raw_text.setter
    def raw_text(self, value): # -> None:
        ...
    
    @property
    def is_reply(self): # -> bool:
        """
        `True` if the message is a reply to some other message.

        Remember that you can access the ID of the message
        this one is replying to through `reply_to.reply_to_msg_id`,
        and the `Message` object with `get_reply_message()`.
        """
        ...
    
    @property
    def forward(self): # -> Forward | None:
        """
        The `Forward <telethon.tl.custom.forward.Forward>`
        information if this message is a forwarded message.
        """
        ...
    
    @property
    def reply_to_chat(self): # -> None:
        """
        The :tl:`Channel` in which the replied-to message was sent,
        if this message is a reply in another chat
        """
        ...
    
    @property
    def reply_to_sender(self): # -> None:
        """
        The :tl:`User`, :tl:`Channel`, or whatever other entity that
        sent the replied-to message, if this message is a reply in another chat.
        """
        ...
    
    @property
    def buttons(self): # -> list[list[MessageButton]] | None:
        """
        Returns a list of lists of `MessageButton
        <telethon.tl.custom.messagebutton.MessageButton>`,
        if any.

        Otherwise, it returns `None`.
        """
        ...
    
    async def get_buttons(self): # -> list[list[MessageButton]] | None:
        """
        Returns `buttons` when that property fails (this is rarely needed).
        """
        ...
    
    @property
    def button_count(self): # -> int:
        """
        Returns the total button count (sum of all `buttons` rows).
        """
        ...
    
    @property
    def file(self): # -> File | None:
        """
        Returns a `File <telethon.tl.custom.file.File>` wrapping the
        `photo` or `document` in this message. If the media type is different
        (polls, games, none, etc.), this property will be `None`.

        This instance lets you easily access other properties, such as
        `file.id <telethon.tl.custom.file.File.id>`,
        `file.name <telethon.tl.custom.file.File.name>`,
        etc., without having to manually inspect the ``document.attributes``.
        """
        ...
    
    @property
    def photo(self): # -> TypePhoto | None:
        """
        The :tl:`Photo` media in this message, if any.

        This will also return the photo for :tl:`MessageService` if its
        action is :tl:`MessageActionChatEditPhoto`, or if the message has
        a web preview with a photo.
        """
        ...
    
    @property
    def document(self): # -> Document | None:
        """
        The :tl:`Document` media in this message, if any.
        """
        ...
    
    @property
    def web_preview(self): # -> WebPage | None:
        """
        The :tl:`WebPage` media in this message, if any.
        """
        ...
    
    @property
    def audio(self): # -> Document | None:
        """
        The :tl:`Document` media in this message, if it's an audio file.
        """
        ...
    
    @property
    def voice(self): # -> Document | None:
        """
        The :tl:`Document` media in this message, if it's a voice note.
        """
        ...
    
    @property
    def video(self): # -> Document | None:
        """
        The :tl:`Document` media in this message, if it's a video.
        """
        ...
    
    @property
    def video_note(self): # -> Document | None:
        """
        The :tl:`Document` media in this message, if it's a video note.
        """
        ...
    
    @property
    def gif(self): # -> Document | None:
        """
        The :tl:`Document` media in this message, if it's a "gif".

        "Gif" files by Telegram are normally ``.mp4`` video files without
        sound, the so called "animated" media. However, it may be the actual
        gif format if the file is too large.
        """
        ...
    
    @property
    def sticker(self): # -> Document | None:
        """
        The :tl:`Document` media in this message, if it's a sticker.
        """
        ...
    
    @property
    def contact(self): # -> MessageMediaContact | None:
        """
        The :tl:`MessageMediaContact` in this message, if it's a contact.
        """
        ...
    
    @property
    def game(self): # -> TypeGame | None:
        """
        The :tl:`Game` media in this message, if it's a game.
        """
        ...
    
    @property
    def geo(self): # -> TypeGeoPoint | None:
        """
        The :tl:`GeoPoint` media in this message, if it has a location.
        """
        ...
    
    @property
    def invoice(self): # -> MessageMediaInvoice | None:
        """
        The :tl:`MessageMediaInvoice` in this message, if it's an invoice.
        """
        ...
    
    @property
    def poll(self): # -> MessageMediaPoll | None:
        """
        The :tl:`MessageMediaPoll` in this message, if it's a poll.
        """
        ...
    
    @property
    def venue(self): # -> MessageMediaVenue | None:
        """
        The :tl:`MessageMediaVenue` in this message, if it's a venue.
        """
        ...
    
    @property
    def dice(self): # -> MessageMediaDice | None:
        """
        The :tl:`MessageMediaDice` in this message, if it's a dice roll.
        """
        ...
    
    @property
    def action_entities(self): # -> list[Any] | None:
        """
        Returns a list of entities that took part in this action.

        Possible cases for this are :tl:`MessageActionChatAddUser`,
        :tl:`types.MessageActionChatCreate`, :tl:`MessageActionChatDeleteUser`,
        :tl:`MessageActionChatJoinedByLink` :tl:`MessageActionChatMigrateTo`
        and :tl:`MessageActionChannelMigrateFrom`.

        If the action is neither of those, the result will be `None`.
        If some entities could not be retrieved, the list may contain
        some `None` items in it.
        """
        ...
    
    @property
    def via_bot(self): # -> None:
        """
        The bot :tl:`User` if the message was sent via said bot.

        This will only be present if `via_bot_id` is not `None` and
        the entity is known.
        """
        ...
    
    @property
    def via_input_bot(self): # -> InputPeerSelf | InputPeerUser | InputPeerChat | InputPeerChannel | InputPeerUserFromMessage | InputPeerChannelFromMessage | InputPeerEmpty | None:
        """
        Returns the input variant of `via_bot`.
        """
        ...
    
    @property
    def reply_to_msg_id(self): # -> int | None:
        """
        Returns the message ID this message is replying to, if any.
        This is equivalent to accessing ``.reply_to.reply_to_msg_id``.
        """
        ...
    
    @property
    def to_id(self): # -> TypePeer:
        """
        Returns the peer to which this message was sent to. This used to exist
        to infer the ``.peer_id``.
        """
        ...
    
    def get_entities_text(self, cls=...): # -> list[Any] | list[tuple[TypeMessageEntity, Any]]:
        """
        Returns a list of ``(markup entity, inner text)``
        (like bold or italics).

        The markup entity is a :tl:`MessageEntity` that represents bold,
        italics, etc., and the inner text is the `str` inside that markup
        entity.

        For example:

        .. code-block:: python

            print(repr(message.text))  # shows: 'Hello **world**!'

            for ent, txt in message.get_entities_text():
                print(ent)  # shows: MessageEntityBold(offset=6, length=5)
                print(txt)  # shows: world

        Args:
            cls (`type`):
                Returns entities matching this type only. For example,
                the following will print the text for all ``code`` entities:

                >>> from telethon.tl.types import MessageEntityCode
                >>>
                >>> m = ...  # get the message
                >>> for _, inner_text in m.get_entities_text(MessageEntityCode):
                >>>     print(inner_text)
        """
        ...
    
    async def get_reply_message(self): # -> None:
        """
        The `Message` that this message is replying to, or `None`.

        The result will be cached after its first use.
        """
        ...
    
    async def respond(self, *args, **kwargs): # -> None:
        """
        Responds to the message (not as a reply). Shorthand for
        `telethon.client.messages.MessageMethods.send_message`
        with ``entity`` already set.
        """
        ...
    
    async def reply(self, *args, **kwargs): # -> None:
        """
        Replies to the message (as a reply). Shorthand for
        `telethon.client.messages.MessageMethods.send_message`
        with both ``entity`` and ``reply_to`` already set.
        """
        ...
    
    async def forward_to(self, *args, **kwargs): # -> None:
        """
        Forwards the message. Shorthand for
        `telethon.client.messages.MessageMethods.forward_messages`
        with both ``messages`` and ``from_peer`` already set.

        If you need to forward more than one message at once, don't use
        this `forward_to` method. Use a
        `telethon.client.telegramclient.TelegramClient` instance directly.
        """
        ...
    
    async def edit(self, *args, **kwargs):
        """
        Edits the message if it's outgoing. Shorthand for
        `telethon.client.messages.MessageMethods.edit_message`
        with both ``entity`` and ``message`` already set.

        Returns
            The edited `Message <telethon.tl.custom.message.Message>`,
            unless `entity` was a :tl:`InputBotInlineMessageID` or :tl:`InputBotInlineMessageID64` in which
            case this method returns a boolean.

        Raises
            ``MessageAuthorRequiredError`` if you're not the author of the
            message but tried editing it anyway.

            ``MessageNotModifiedError`` if the contents of the message were
            not modified at all.

            ``MessageIdInvalidError`` if the ID of the message is invalid
            (the ID itself may be correct, but the message with that ID
            cannot be edited). For example, when trying to edit messages
            with a reply markup (or clear markup) this error will be raised.

        .. note::

            This is different from `client.edit_message
            <telethon.client.messages.MessageMethods.edit_message>`
            and **will respect** the previous state of the message.
            For example, if the message didn't have a link preview,
            the edit won't add one by default, and you should force
            it by setting it to `True` if you want it.

            This is generally the most desired and convenient behaviour,
            and will work for link previews and message buttons.
        """
        ...
    
    async def delete(self, *args, **kwargs): # -> None:
        """
        Deletes the message. You're responsible for checking whether you
        have the permission to do so, or to except the error otherwise.
        Shorthand for
        `telethon.client.messages.MessageMethods.delete_messages` with
        ``entity`` and ``message_ids`` already set.

        If you need to delete more than one message at once, don't use
        this `delete` method. Use a
        `telethon.client.telegramclient.TelegramClient` instance directly.
        """
        ...
    
    async def download_media(self, *args, **kwargs): # -> None:
        """
        Downloads the media contained in the message, if any. Shorthand
        for `telethon.client.downloads.DownloadMethods.download_media`
        with the ``message`` already set.
        """
        ...
    
    async def click(self, i=..., j=..., *, text=..., filter=..., data=..., share_phone=..., share_geo=..., password=...): # -> bool | None:
        """
        Calls :tl:`SendVote` with the specified poll option
        or `button.click <telethon.tl.custom.messagebutton.MessageButton.click>`
        on the specified button.

        Does nothing if the message is not a poll or has no buttons.

        Args:
            i (`int` | `list`):
                Clicks the i'th button or poll option (starting from the index 0).
                For multiple-choice polls, a list with the indices should be used.
                Will ``raise IndexError`` if out of bounds. Example:

                >>> message = ...  # get the message somehow
                >>> # Clicking the 3rd button
                >>> # [button1] [button2]
                >>> # [     button3     ]
                >>> # [button4] [button5]
                >>> await message.click(2)  # index

            j (`int`):
                Clicks the button at position (i, j), these being the
                indices for the (row, column) respectively. Example:

                >>> # Clicking the 2nd button on the 1st row.
                >>> # [button1] [button2]
                >>> # [     button3     ]
                >>> # [button4] [button5]
                >>> await message.click(0, 1)  # (row, column)

                This is equivalent to ``message.buttons[0][1].click()``.

            text (`str` | `callable`):
                Clicks the first button or poll option with the text "text". This may
                also be a callable, like a ``re.compile(...).match``,
                and the text will be passed to it.

                If you need to select multiple options in a poll,
                pass a list of indices to the ``i`` parameter.

            filter (`callable`):
                Clicks the first button or poll option for which the callable
                returns `True`. The callable should accept a single
                `MessageButton <telethon.tl.custom.messagebutton.MessageButton>`
                or `PollAnswer <telethon.tl.types.PollAnswer>` argument.

                If you need to select multiple options in a poll,
                pass a list of indices to the ``i`` parameter.

            data (`bytes`):
                This argument overrides the rest and will not search any
                buttons. Instead, it will directly send the request to
                behave as if it clicked a button with said data. Note
                that if the message does not have this data, it will
                ``raise DataInvalidError``.

            share_phone (`bool` | `str` | tl:`InputMediaContact`):
                When clicking on a keyboard button requesting a phone number
                (:tl:`KeyboardButtonRequestPhone`), this argument must be
                explicitly set to avoid accidentally sharing the number.

                It can be `True` to automatically share the current user's
                phone, a string to share a specific phone number, or a contact
                media to specify all details.

                If the button is pressed without this, `ValueError` is raised.

            share_geo (`tuple` | `list` | tl:`InputMediaGeoPoint`):
                When clicking on a keyboard button requesting a geo location
                (:tl:`KeyboardButtonRequestGeoLocation`), this argument must
                be explicitly set to avoid accidentally sharing the location.

                It must be a `tuple` of `float` as ``(longitude, latitude)``,
                or a :tl:`InputGeoPoint` instance to avoid accidentally using
                the wrong roder.

                If the button is pressed without this, `ValueError` is raised.

            password (`str`):
                When clicking certain buttons (such as BotFather's confirmation
                button to transfer ownership), if your account has 2FA enabled,
                you need to provide your account's password. Otherwise,
                `teltehon.errors.PasswordHashInvalidError` is raised.

            Example:

                .. code-block:: python

                    # Click the first button
                    await message.click(0)

                    # Click some row/column
                    await message.click(row, column)

                    # Click by text
                    await message.click(text='👍')

                    # Click by data
                    await message.click(data=b'payload')

                    # Click on a button requesting a phone
                    await message.click(0, share_phone=True)
        """
        ...
    
    async def mark_read(self): # -> None:
        """
        Marks the message as read. Shorthand for
        `client.send_read_acknowledge()
        <telethon.client.messages.MessageMethods.send_read_acknowledge>`
        with both ``entity`` and ``message`` already set.
        """
        ...
    
    async def pin(self, *, notify=..., pm_oneside=...): # -> None:
        """
        Pins the message. Shorthand for
        `telethon.client.messages.MessageMethods.pin_message`
        with both ``entity`` and ``message`` already set.
        """
        ...
    
    async def unpin(self): # -> None:
        """
        Unpins the message. Shorthand for
        `telethon.client.messages.MessageMethods.unpin_message`
        with both ``entity`` and ``message`` already set.
        """
        ...
    


