import asyncio
from telethon import TelegramClient
from telethon.errors import RPCError
from telethon.tl.types import User
from telethon.tl.custom.message import Message
from datetime import datetime
from pathlib import Path
from domain.models import Config
from interfaces.telegram_client import create_telegram_client
from application.error_reporter import log_rpc_error, log_exception

DOWNLOAD_ROOT = Path("download")

def ensure_dir(path: Path):
    if not path.exists():
        print(f"üìÇ –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ç–∞–ª–æ–≥–∞: {path}")
        path.mkdir(parents=True, exist_ok=True)  

def format_message_md(msg: Message) -> str:
    date_str = msg.date.strftime("### %Y-%m-%d\n## %H:%M:%S")
    username = f"@{msg.sender.username}" if hasattr(msg.sender, "username") else "@unknown"
    content = msg.message or ""
    media_tag = " - (media)" if msg.media else ""
    return f"{date_str}\n{username}\n{content}{media_tag}\n\n"

async def export_private_chat(config: Config):
    client = create_telegram_client(config)
    try:
        await client.start()
        if not await client.is_user_authorized():
            print("üîí –°–µ—Å—Å–∏—è –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–∞. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –≤—Ö–æ–¥ —á–µ—Ä–µ–∑ –º–µ–Ω—é '2. Connect'.")
            return
    except Exception as e:
        print("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∫–ª–∏–µ–Ω—Ç–∞.")
        log_exception("client_start", e)
        return

    try:
        print("üîç –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–æ–≤...")

        users = []
        async for dialog in client.iter_dialogs():
            if isinstance(dialog.entity, User) and dialog.is_user and not dialog.entity.deleted:
                users.append(dialog)

        if not users:
            print("‚ùå –õ–∏—á–Ω—ã–µ —á–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
            return

        print("\nüìú –°–ø–∏—Å–æ–∫ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–æ–≤:")
        for idx, usr in enumerate(users, 1):
            name = f"{usr.name} ({usr.entity.username})" if usr.entity.username else usr.name
            print(f"{idx}. {name}")

        selected = int(input("\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —á–∞—Ç–∞: ")) - 1
        user = users[selected]
        print(f"\n‚úÖ –í—ã–±—Ä–∞–Ω: {user.name}")

        choice = input("üí¨ –£–∫–∞–∑–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω —Å–æ–æ–±—â–µ–Ω–∏–π? (all / <–æ—Ç>:<–¥–æ>) ").strip()
        if choice == "all":
            from_id, to_id = None, None
        else:
            try:
                parts = choice.split(":")
                from_id, to_id = int(parts[0]), int(parts[1])
            except:
                print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.")
                return

        download_dir = DOWNLOAD_ROOT / "private" / user.name.replace(" ", "_")
        ensure_dir(download_dir)

        try:
            messages = await client.get_messages(user, limit=None)
        except RPCError as e:
            log_rpc_error(e)
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π: {e}")
            return

        print(f"üìù –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(messages)} —Å–æ–æ–±—â–µ–Ω–∏–π")

        save_md = []
        for msg in reversed(messages):
            if from_id and (msg.id < from_id or msg.id > to_id):
                continue

            save_md.append(format_message_md(msg))

            if msg.media:
                try:
                    print(f"üì• –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –º–µ–¥–∏–∞: —Å–æ–æ–±—â–µ–Ω–∏–µ {msg.id}")
                    await client.download_media(msg, file=download_dir)
                except Exception as e:
                    print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –º–µ–¥–∏–∞ (id {msg.id}): {e}")
                    log_exception("download_media", e)

        md_path = download_dir / "chat.md"
        with open(md_path, "w", encoding="utf-8") as f:
            f.writelines(save_md)

        print(f"‚úÖ –ü–µ—Ä–µ–ø–∏—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {md_path}")

    except Exception as e:
        print("‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ —á–∞—Ç–∞.")
        log_exception("export_private_chat", e)
    finally:
        if client.is_connected():
            await client.disconnect()


# async def export_private_chat(config: Config):
#     client = create_telegram_client(config)
#     try:
#         await client.start()
#         if not await client.is_user_authorized():
#             print("üîí –°–µ—Å—Å–∏—è –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–∞. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –≤—Ö–æ–¥ —á–µ—Ä–µ–∑ –º–µ–Ω—é '2. Connect'.")
#             return
#     except Exception as e:
#         print("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∫–ª–∏–µ–Ω—Ç–∞.")
#         log_exception("client_start", e)
#         return

#     try:
#         print("üîç –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–æ–≤...")

#         users = []
#         async for dialog in client.iter_dialogs():
#             if isinstance(dialog.entity, User) and dialog.is_user:
#                 users.append(dialog)

#         if not users:
#             print("‚ùå –õ–∏—á–Ω—ã–µ —á–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
#             return

#         print("\nüìú –°–ø–∏—Å–æ–∫ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–æ–≤:")
#         for idx, usr in enumerate(users, 1):
#             name = f"{usr.name} ({usr.entity.username})" if usr.entity.username else usr.name
#             print(f"{idx}. {name}")

#         selected = int(input("\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —á–∞—Ç–∞: ")) - 1
#         user = users[selected]
#         print(f"\n‚úÖ –í—ã–±—Ä–∞–Ω: {user.name}")

#         choice = input("üí¨ –£–∫–∞–∑–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω —Å–æ–æ–±—â–µ–Ω–∏–π? (all / <–æ—Ç>:<–¥–æ>) ").strip()
#         if choice == "all":
#             from_id, to_id = None, None
#         else:
#             try:
#                 parts = choice.split(":")
#                 from_id, to_id = int(parts[0]), int(parts[1])
#             except:
#                 print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.")
#                 return

#         download_dir = DOWNLOAD_ROOT / "private" / user.name.replace(" ", "_")
#         ensure_dir(download_dir)

#         try:
#             messages = await client.get_messages(user, limit=None)
#         except RPCError as e:
#             log_rpc_error(e)
#             print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π: {e}")
#             return

#         print(f"üìù –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(messages)} —Å–æ–æ–±—â–µ–Ω–∏–π")

#         save_md = []
#         for msg in reversed(messages):
#             if from_id and (msg.id < from_id or msg.id > to_id):
#                 continue

#             save_md.append(format_message_md(msg))

#             if msg.media:
#                 try:
#                     print(f"üì• –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –º–µ–¥–∏–∞: —Å–æ–æ–±—â–µ–Ω–∏–µ {msg.id}")
#                     await client.download_media(msg, file=download_dir)
#                 except Exception as e:
#                     print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –º–µ–¥–∏–∞ (id {msg.id}): {e}")
#                     log_exception("download_media", e)

#         md_path = download_dir / "chat.md"
#         with open(md_path, "w", encoding="utf-8") as f:
#             f.writelines(save_md)

#         print(f"‚úÖ –ü–µ—Ä–µ–ø–∏—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {md_path}")

#     except Exception as e:
#         print("‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ —á–∞—Ç–∞.")
#         log_exception("export_private_chat", e)
#     finally:
#         if client.is_connected():
#             await client.disconnect()
